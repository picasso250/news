[Lil'Log](https://lilianweng.github.io/) | [Posts](https://lilianweng.github.io/) [Archive](https://lilianweng.github.io/archives) [Search](https://lilianweng.github.io/search/) [Tags](https://lilianweng.github.io/tags/) [FAQ](https://lilianweng.github.io/faq)
# Learning Word Embedding
Date: October 15, 2017 | Estimated Reading Time: 18 min | Author: Lilian Weng Table of Contents [Count-Based Vector Space Model](#count-based-vector-space-model) [Context-Based: Skip-Gram Model](#context-based-skip-gram-model) [Context-Based: Continuous Bag-of-Words (CBOW)](#context-based-continuous-bag-of-words-cbow) [Loss Functions](#loss-functions) [Full Softmax](#full-softmax) [Hierarchical Softmax](#hierarchical-softmax) [Cross Entropy](#cross-entropy) [Noise Contrastive Estimation (NCE)](#noise-contrastive-estimation-nce) [Negative Sampling (NEG)](#negative-sampling-neg) [Other Tips for Learning Word Embedding](#other-tips-for-learning-word-embedding) [GloVe: Global Vectors](#glove-global-vectors) [Examples: word2vec on “Game of Thrones”](#examples-word2vec-on-game-of-thrones) [References](#references) Word embedding is a dense representation of words in the form of numeric vectors. It can be learned using a variety of language models. The word embedding representation is able to reveal many hidden relationships between words. For example, vector("cat") - vector("kitten") is similar to vector("dog") - vector("puppy"). This post introduces several models for learning word embedding and how their loss functions are designed for the purpose.
Human vocabulary comes in free text. In order to make a machine learning model understand and process the natural language, we need to transform the free-text words into numeric values. One of the simplest transformation approaches is to do a one-hot encoding in which each distinct word stands for one dimension of the resulting vector and a binary value indicates whether the word presents (1) or not (0).
However, one-hot encoding is impractical computationally when dealing with the entire vocabulary, as the representation demands hundreds of thousands of dimensions. Word embedding represents words and phrases in vectors of (non-binary) numeric values with much lower and thus denser dimensions. An intuitive assumption for good word embedding is that they can approximate the similarity between words (i.e., “cat” and “kitten” are similar words, and thus they are expected to be close in the reduced vector space) or disclose hidden semantic relationships (i.e., the relationship between “cat” and “kitten” is an analogy to the one between “dog” and “puppy”). Contextual information is super useful for learning word meaning and relationship, as similar words may appear in the similar context often.
There are two main approaches for learning word embedding, both relying on the contextual knowledge.
Count-based : The first one is unsupervised, based on matrix factorization of a global word co-occurrence matrix. Raw co-occurrence counts do not work well, so we want to do smart things on top. Context-based : The second approach is supervised. Given a local context, we want to design a model to predict the target words and in the meantime, this model learns the efficient word embedding representation.
# Count-Based Vector Space Model [#](#count-based-vector-space-model)
Count-based vector space models heavily rely on the word frequency and co-occurrence matrix with the assumption that words in the same contexts share similar or related semantic meanings. The models map count-based statistics like co-occurrences between neighboring words down to a small and dense word vectors. PCA, topic models, and neural probabilistic language models are all good examples of this category.
Different from the count-based approaches, context-based methods build predictive models that directly target at predicting a word given its neighbors. The dense word vectors are part of the model parameters. The best vector representation of each word is learned during the model training process.
# Context-Based: Skip-Gram Model [#](#context-based-skip-gram-model)
Suppose that you have a sliding window of a fixed size moving along a sentence: the word in the middle is the “target” and those on its left and right within the sliding window are the context words. The skip-gram model ( [Mikolov et al., 2013](https://arxiv.org/pdf/1301.3781.pdf) ) is trained to predict the probabilities of a word being a context word for the given target.
The following example demonstrates multiple pairs of target and context words as training samples, generated by a 5-word window sliding along the sentence.
“The man who passes the sentence should swing the sword.” – Ned Stark
| Sliding window (size = 5) | Target word | Context |
|---|---|---|
| [The man who] | the | man, who |
| [The man who passes] | man | the, who, passes |
| [The man who passes the] | who | the, man, passes, the |
| [man who passes the sentence] | passes | man, who, the, sentence |
| … | … | … |
| [sentence should swing the sword] | swing | sentence, should, the, sword |
| [should swing the sword] | the | should, swing, sword |
| [swing the sword] | sword | swing, the |
| {:.info} | | |
Each context-target pair is treated as a new observation in the data. For example, the target word “swing” in the above case produces four training samples: (“swing”, “sentence”), (“swing”, “should”), (“swing”, “the”), and (“swing”, “sword”).
The skip-gram model. Both the input vector x and the output y are one-hot encoded word representations. The hidden layer is the word embedding of size N .
Given the vocabulary size V , we are about to learn word embedding vectors of size N . The model learns to predict one context word (output) using one target word (input) at a time.
According to Fig. 1,
Both input word w i and the output word w j are one-hot encoded into binary vectors x and y of size V . First, the multiplication of the binary vector x and the word embedding matrix W of size V × N gives us the embedding vector of the input word w i : the i-th row of the matrix W . This newly discovered embedding vector of dimension N forms the hidden layer. The multiplication of the hidden layer and the word context matrix W ′ of size N × V produces the output one-hot encoded vector y . The output context matrix W ′ encodes the meanings of words as context, different from the embedding matrix W . NOTE: Despite the name, W ′ is independent of W , not a transpose or inverse or whatsoever.
# Context-Based: Continuous Bag-of-Words (CBOW) [#](#context-based-continuous-bag-of-words-cbow)
The Continuous Bag-of-Words (CBOW) is another similar model for learning word vectors. It predicts the target word (i.e. “swing”) from source context words (i.e., “sentence should the sword”).
The CBOW model. Word vectors of multiple context words are averaged to get a fixed-length vector as in the hidden layer. Other symbols have the same meanings as in Fig 1.
Because there are multiple contextual words, we average their corresponding word vectors, constructed by the multiplication of the input vector and the matrix W . Because the averaging stage smoothes over a lot of the distributional information, some people believe the CBOW model is better for small dataset.
# Loss Functions [#](#loss-functions)
Both the skip-gram model and the CBOW model should be trained to minimize a well-designed loss/objective function. There are several loss functions we can incorporate to train these language models. In the following discussion, we will use the skip-gram model as an example to describe how the loss is computed.
## Full Softmax [#](#full-softmax)
The skip-gram model defines the embedding vector of every word by the matrix W and the context vector by the output matrix W ′ . Given an input word w I , let us label the corresponding row of W as vector v w I (embedding vector) and its corresponding column of W ′ as v w I ′ (context vector). The final output layer applies softmax to compute the probability of predicting the output word w O given w I , and therefore:
p ( w O | w I ) = exp ⁡ ( v w O ′ ⊤ v w I ) ∑ i = 1 V exp ⁡ ( v w i ′ ⊤ v w I )
This is accurate as presented in However, when V is extremely large, calculating the denominator by going through all the words for every single sample is computationally impractical. The demand for more efficient conditional probability estimation leads to the new methods like hierarchical softmax .
## Hierarchical Softmax [#](#hierarchical-softmax)
Morin and Bengio ( [2005](https://www.iro.umontreal.ca/~lisa/pointeurs/hierarchical-nnlm-aistats05.pdf) ) proposed hierarchical softmax to make the sum calculation faster with the help of a binary tree structure. The hierarchical softmax encodes the language model’s output softmax layer into a tree hierarchy, where each leaf is one word and each internal node stands for relative probabilities of the children nodes.
An illustration of the hierarchical softmax binary tree. The leaf nodes in white are words in the vocabulary. The gray inner nodes carry information on the probabilities of reaching its child nodes. One path starting from the root to the leaf w _ i . n ( w _ i , j ) denotes the j-th node on this path. (Image source: [word2vec Parameter Learning Explained](https://arxiv.org/pdf/1411.2738.pdf) )
Each word w i has a unique path from the root down to its corresponding leaf. The probability of picking this word is equivalent to the probability of taking this path from the root down through the tree branches. Since we know the embedding vector v n of the internal node n , the probability of getting the word can be computed by the product of taking left or right turn at every internal node stop.
According to Fig. 3, the probability of one node is ( σ is the sigmoid function):
p ( turn right → … w I | n ) = σ ( v n ′ ⊤ v w I ) p ( turn left → … w I | n ) = 1 − p ( turn right | n ) = σ ( − v n ′ ⊤ v w I )
The final probability of getting a context word w O given an input word w I is:
p ( w O | w I ) = ∏ k = 1 L ( w O ) σ ( I turn ( n ( w O , k ) , n ( w O , k + 1 ) ) ⋅ v n ( w O , k ) ′ ⊤ v w I )
where L ( w O ) is the depth of the path leading to the word w O and I turn is a specially indicator function which returns 1 if n ( w O , k + 1 ) is the left child of n ( w O , k ) otherwise -1. The internal nodes’ embeddings are learned during the model training. The tree structure helps greatly reduce the complexity of the denominator estimation from O(V) (vocabulary size) to O(log V) (the depth of the tree) at the training time. However, at the prediction time, we still to compute the probability of every word and pick the best, as we don’t know which leaf to reach for in advance.
A good tree structure is crucial to the model performance. Several handy principles are: group words by frequency like what is implemented by Huffman tree for simple speedup; group similar words into same or close branches (i.e. use predefined word clusters, WordNet).
Morin and Bengio use the synsets in WordNet as clusters for the tree. Mnih and Hinton learn the tree structure with a clustering algorithm that recursively partitions the words in two clusters.
## Cross Entropy [#](#cross-entropy)
Another approach completely steers away from the softmax framework. Instead, the loss function measures the cross entropy between the predicted probabilities p and the true binary labels y .
First, let’s recall that the cross entropy between two distributions p and q is measured as H ( p , q ) = − ∑ x p ( x ) log ⁡ q ( x ) . In our case, the true label y i is 1 only when w i is the output word; y j is 0 otherwise. The loss function L θ of the model with parameter config θ aims to minimize the cross entropy between the prediction and the ground truth, as lower cross entropy indicates high similarity between two distributions.
L θ = − ∑ i = 1 V y i log ⁡ p ( w i | w I ) = − log ⁡ p ( w O | w I )
Recall that,
p ( w O | w I ) = exp ⁡ ( v w O ′ ⊤ v w I ) ∑ i = 1 V exp ⁡ ( v w i ′ ⊤ v w I )
Therefore,
L θ = − log ⁡ exp ⁡ ( v w O ′ ⊤ v w I ) ∑ i = 1 V exp ⁡ ( v w i ′ ⊤ v w I ) = − v w O ′ ⊤ v w I + log ⁡ ∑ i = 1 V exp ⁡ ( v w i ′ ⊤ v w I )
To start training the model using back-propagation with SGD, we need to compute the gradient of the loss function. For simplicity, let’s label z I O = v w O ′ ⊤ v w I .
∇ θ L θ = ∇ θ ( − z I O + log ⁡ ∑ i = 1 V e z I i ) = − ∇ θ z I O + ∇ θ ( log ⁡ ∑ i = 1 V e z I i ) = − ∇ θ z I O + 1 ∑ i = 1 V e z I i ∑ i = 1 V e z I i ∇ θ z I i = − ∇ θ z I O + ∑ i = 1 V e z I i ∑ i = 1 V e z I i ∇ θ z I i = − ∇ θ z I O + ∑ i = 1 V p ( w i | w I ) ∇ θ z I i = − ∇ θ z I O + E w i ∼ Q ( w ~ ) ∇ θ z I i
where Q ( w ~ ) is the distribution of noise samples.
According to the formula above, the correct output word has a positive reinforcement according to the first term (the larger ∇ θ z I O the better loss we have), while other words have a negative impact as captured by the second term.
How to estimate E w i ∼ Q ( w ~ ) ∇ θ v w i ′ ⊤ v w I with a sample set of noise words rather than scanning through the entire vocabulary is the key of using cross-entropy-based sampling approach.
## Noise Contrastive Estimation (NCE) [#](#noise-contrastive-estimation-nce)
The Noise Contrastive Estimation (NCE) metric intends to differentiate the target word from noise samples using a logistic regression classifier ( [Gutmann and Hyvärinen, 2010](http://proceedings.mlr.press/v9/gutmann10a/gutmann10a.pdf) ).
Given an input word w I , the correct output word is known as w . In the meantime, we sample N other words from the noise sample distribution Q , denoted as w ~ 1 , w ~ 2 , … , w ~ N ∼ Q . Let’s label the decision of the binary classifier as d and d $ can only take a binary value.
L θ = − [ log ⁡ p ( d = 1 | w , w I ) + ∑ i = 1 , w ~ i ∼ Q N log ⁡ p ( d = 0 | w ~ i , w I ) ]
When N is big enough, according to [the Law of large numbers](https://en.wikipedia.org/wiki/Law_of_large_numbers) ,
L θ = − [ log ⁡ p ( d = 1 | w , w I ) + N E w ~ i ∼ Q log ⁡ p ( d = 0 | w ~ i , w I ) ]
To compute the probability p ( d = 1 | w , w I ) , we can start with the joint probability p ( d , w | w I ) . Among w , w ~ 1 , w ~ 2 , … , w ~ N , we have 1 out of (N+1) chance to pick the true word w , which is sampled from the conditional probability p ( w | w I ) ; meanwhile, we have N out of (N+1) chances to pick a noise word, each sampled from q ( w ~ ) ∼ Q . Thus,
p ( d , w | w I ) = { 1 N + 1 p ( w | w I ) if d = 1 N N + 1 q ( w ~ ) if d = 0
Then we can figure out p ( d = 1 | w , w I ) and p ( d = 0 | w , w I ) :
p ( d = 1 | w , w I ) = p ( d = 1 , w | w I ) p ( d = 1 , w | w I ) + p ( d = 0 , w | w I ) = p ( w | w I ) p ( w | w I ) + N q ( w ~ ) p ( d = 0 | w , w I ) = p ( d = 0 , w | w I ) p ( d = 1 , w | w I ) + p ( d = 0 , w | w I ) = N q ( w ~ ) p ( w | w I ) + N q ( w ~ )
Finally the loss function of NCE’s binary classifier becomes:
L θ = − [ log ⁡ p ( d = 1 | w , w I ) + ∑ i = 1 w ~ i ∼ Q N log ⁡ p ( d = 0 | w ~ i , w I ) ] = − [ log ⁡ p ( w | w I ) p ( w | w I ) + N q ( w ~ ) + ∑ i = 1 w ~ i ∼ Q N log ⁡ N q ( w ~ i ) p ( w | w I ) + N q ( w ~ i ) ]
However, p ( w | w I ) still involves summing up the entire vocabulary in the denominator. Let’s label the denominator as a partition function of the input word, Z ( w I ) . A common assumption is Z ( w ) ≈ 1 given that we expect the softmax output layer to be normalized ( [Minh and Teh, 2012](https://www.cs.toronto.edu/~amnih/papers/ncelm.pdf) ). Then the loss function is simplified to:
L θ = − [ log ⁡ exp ⁡ ( v w ′ ⊤ v w I ) exp ⁡ ( v w ′ ⊤ v w I ) + N q ( w ~ ) + ∑ i = 1 w ~ i ∼ Q N log ⁡ N q ( w ~ i ) exp ⁡ ( v w ′ ⊤ v w I ) + N q ( w ~ i ) ]
The noise distribution Q is a tunable parameter and we would like to design it in a way so that:
intuitively it should be very similar to the real data distribution; and it should be easy to sample from.
For example, the sampling implementation ( [log_uniform_candidate_sampler](https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/ops/candidate_sampling_ops.py#L83) ) of NCE loss in tensorflow assumes that such noise samples follow a log-uniform distribution, also known as [Zipfian’s law](https://en.wikipedia.org/wiki/Zipf%27s_law) . The probability of a given word in logarithm is expected to be reversely proportional to its rank, while high-frequency words are assigned with lower ranks. In this case, q ( w ~ ) = 1 log ⁡ V ( log ⁡ ( r w ~ + 1 ) − log ⁡ r w ~ ) , where r w ~ ∈ [ 1 , V ] is the rank of a word by frequency in descending order.
## Negative Sampling (NEG) [#](#negative-sampling-neg)
The Negative Sampling (NEG) proposed by Mikolov et al. ( [2013](https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf) ) is a simplified variation of NCE loss. It is especially famous for training Google’s [word2vec](https://code.google.com/archive/p/word2vec/) project. Different from NCE Loss which attempts to approximately maximize the log probability of the softmax output, negative sampling did further simplification because it focuses on learning high-quality word embedding rather than modeling the word distribution in natural language.
NEG approximates the binary classifier’s output with sigmoid functions as follows:
p ( d = 1 | w , w I ) = σ ( v w ′ ⊤ v w I ) p ( d = 0 | w , w I ) = 1 − σ ( v w ′ ⊤ v w I ) = σ ( − v w ′ ⊤ v w I )
The final NCE loss function looks like:
L θ = − [ log ⁡ σ ( v w ′ ⊤ v w I ) + ∑ i = 1 w ~ i ∼ Q N log ⁡ σ ( − v w ~ i ′ ⊤ v w I ) ]
# Other Tips for Learning Word Embedding [#](#other-tips-for-learning-word-embedding)
Mikolov et al. ( [2013](https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf) ) suggested several helpful practices that could result in good word embedding learning outcomes.
Soft sliding window . When pairing the words within the sliding window, we could assign less weight to more distant words. One heuristic is — given a maximum window size parameter defined, s max , the actual window size is randomly sampled between 1 and s max for every training sample. Thus, each context word has the probability of 1/(its distance to the target word) being observed, while the adjacent words are always observed.
Subsampling frequent words . Extremely frequent words might be too general to differentiate the context (i.e. think about stopwords). While on the other hand, rare words are more likely to carry distinct information. To balance the frequent and rare words, Mikolov et al. proposed to discard words w with probability 1 − t / f ( w ) during sampling. Here f ( w ) is the word frequency and t is an adjustable threshold.
Learning phrases first . A phrase often stands as a conceptual unit, rather than a simple composition of individual words. For example, we cannot really tell “New York” is a city name even we know the meanings of “new” and “york”. Learning such phrases first and treating them as word units before training the word embedding model improves the outcome quality. A simple data-driven approach is based on unigram and bigram counts: s phrase = C ( w i w j ) − δ C ( w i ) C ( w j ) , where C ( . ) is simple count of an unigram w i or bigram w i w j and δ is a discounting threshold to prevent super infrequent words and phrases. Higher scores indicate higher chances of being phrases. To form phrases longer than two words, we can scan the vocabulary multiple times with decreasing score cutoff values.
# GloVe: Global Vectors [#](#glove-global-vectors)
The Global Vector (GloVe) model proposed by Pennington et al. ( [2014](http://www.aclweb.org/anthology/D14-1162) ) aims to combine the count-based matrix factorization and the context-based skip-gram model together.
We all know the counts and co-occurrences can reveal the meanings of words. To distinguish from p ( w O | w I ) in the context of a word embedding word, we would like to define the co-ocurrence probability as:
p co ( w k | w i ) = C ( w i , w k ) C ( w i )
C ( w i , w k ) counts the co-occurrence between words w i and w k .
Say, we have two words, w i =“ice” and w j =“steam”. The third word w ~ k =“solid” is related to “ice” but not “steam”, and thus we expect p co ( w ~ k | w i ) to be much larger than p co ( w ~ k | w j ) and therefore p co ( w ~ k | w i ) p co ( w ~ k | w j ) to be very large. If the third word w ~ k = “water” is related to both or w ~ k = “fashion” is unrelated to either of them, p co ( w ~ k | w i ) p co ( w ~ k | w j ) is expected to be close to one.
The intuition here is that the word meanings are captured by the ratios of co-occurrence probabilities rather than the probabilities themselves. The global vector models the relationship between two words regarding to the third context word as:
F ( w i , w j , w ~ k ) = p co ( w ~ k | w i ) p co ( w ~ k | w j )
Further, since the goal is to learn meaningful word vectors, F is designed to be a function of the linear difference between two words w i − w j :
F ( ( w i − w j ) ⊤ w ~ k ) = p co ( w ~ k | w i ) p co ( w ~ k | w j )
With the consideration of F being symmetric between target words and context words, the final solution is to model F as an exponential function. Please read the original paper ( [Pennington et al., 2014](http://www.aclweb.org/anthology/D14-1162) ) for more details of the equations.
F ( w i ⊤ w ~ k ) = exp ⁡ ( w i ⊤ w ~ k ) = p co ( w ~ k | w i ) F ( ( w i − w j ) ⊤ w ~ k ) = exp ⁡ ( ( w i − w j ) ⊤ w ~ k ) = exp ⁡ ( w i ⊤ w ~ k ) exp ⁡ ( w j ⊤ w ~ k ) = p co ( w ~ k | w i ) p co ( w ~ k | w j )
Finally,
w i ⊤ w ~ k = log ⁡ p co ( w ~ k | w i ) = log ⁡ C ( w i , w ~ k ) C ( w i ) = log ⁡ C ( w i , w ~ k ) − log ⁡ C ( w i )
Since the second term − log ⁡ C ( w i ) is independent of k , we can add bias term b i for w i to capture − log ⁡ C ( w i ) . To keep the symmetric form, we also add in a bias b ~ k for w ~ k .
log ⁡ C ( w i , w ~ k ) = w i ⊤ w ~ k + b i + b ~ k
The loss function for the GloVe model is designed to preserve the above formula by minimizing the sum of the squared errors:
L θ = ∑ i = 1 , j = 1 V f ( C ( w i , w j ) ) ( w i ⊤ w ~ j + b i + b ~ j − log ⁡ C ( w i , w ~ j ) ) 2
The weighting schema f ( c ) is a function of the co-occurrence of w i and w j and it is an adjustable model configuration. It should be close to zero as c → 0 ; should be non-decreasing as higher co-occurrence should have more impact; should saturate when c become extremely large. The paper proposed the following weighting function.
f ( c ) = { ( c c max ) α if c < c max , c max is adjustable. 1 if otherwise
# Examples: word2vec on “Game of Thrones” [#](#examples-word2vec-on-game-of-thrones)
After reviewing all the theoretical knowledge above, let’s try a little experiment in word embedding extracted from “the Games of Thrones corpus”. The process is super straightforward using [gensim](https://radimrehurek.com/gensim/models/word2vec.html) .
Step 1: Extract words
import sys from nltk.corpus import stopwords from nltk.tokenize import sent_tokenize STOP_WORDS = set(stopwords . words( 'english' )) def get_words ( txt ): return filter( lambda x: x not in STOP_WORDS, re . findall( r '\b(\w+)\b' , txt) ) def parse_sentence_words ( input_file_names ): """Returns a list of a list of words. Each sublist is a sentence.""" sentence_words = [] for file_name in input_file_names: for line in open(file_name): line = line . strip() . lower() line = line . decode( 'unicode_escape' ) . encode( 'ascii' , 'ignore' ) sent_words = map(get_words, sent_tokenize(line)) sent_words = filter( lambda sw: len(sw) > 1 , sent_words) if len(sent_words) > 1 : sentence_words += sent_words return sentence_words # You would see five .txt files after unzip 'a_song_of_ice_and_fire.zip' input_file_names = [ "001ssb.txt" , "002ssb.txt" , "003ssb.txt" , "004ssb.txt" , "005ssb.txt" ] GOT_SENTENCE_WORDS = parse_sentence_words(input_file_names) copy
Step 2: Feed a word2vec model
from gensim.models import Word2Vec # size: the dimensionality of the embedding vectors. # window: the maximum distance between the current and predicted word within a sentence. model = Word2Vec(GOT_SENTENCE_WORDS, size = 128 , window = 3 , min_count = 5 , workers = 4 ) model . wv . save_word2vec_format( "got_word2vec.txt" , binary = False ) copy
Step 3: Check the results
In the GoT word embedding space, the top similar words to “king” and “queen” are:
| model.most_similar('king', topn=10) (word, similarity with ‘king’) | model.most_similar('queen', topn=10) (word, similarity with ‘queen’) |
|---|---|
| (‘kings’, 0.897245) | (‘cersei’, 0.942618) |
| (‘baratheon’, 0.809675) | (‘joffrey’, 0.933756) |
| (‘son’, 0.763614) | (‘margaery’, 0.931099) |
| (‘robert’, 0.708522) | (‘sister’, 0.928902) |
| (’lords’, 0.698684) | (‘prince’, 0.927364) |
| (‘joffrey’, 0.696455) | (‘uncle’, 0.922507) |
| (‘prince’, 0.695699) | (‘varys’, 0.918421) |
| (‘brother’, 0.685239) | (’ned’, 0.917492) |
| (‘aerys’, 0.684527) | (‘melisandre’, 0.915403) |
| (‘stannis’, 0.682932) | (‘robb’, 0.915272) |
Cited as:
@article{weng2017wordembedding,
title = "Learning word embedding" ,
author = "Weng, Lilian" ,
journal = "lilianweng.github.io" ,
year = "2017" ,
url = "https://lilianweng.github.io/posts/2017-10-15-word-embedding/" } copy
# References [#](#references)
[1] Tensorflow Tutorial [Vector Representations of Words](https://www.tensorflow.org/tutorials/word2vec) .
[2] [“Word2Vec Tutorial - The Skip-Gram Model”](http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/) by Chris McCormick.
[3] [“On word embeddings - Part 2: Approximating the Softmax”](http://ruder.io/word-embeddings-softmax/) by Sebastian Ruder.
[4] Xin Rong. [word2vec Parameter Learning Explained](https://arxiv.org/pdf/1411.2738.pdf)
[5] Mikolov, Tomas, Kai Chen, Greg Corrado, and Jeffrey Dean. [“Efficient estimation of word representations in vector space.”](https://arxiv.org/pdf/1301.3781.pdf) arXiv preprint arXiv:1301.3781 (2013).
[6] Frederic Morin and Yoshua Bengio. [“Hierarchical Probabilistic Neural Network Language Model.”](https://www.iro.umontreal.ca/~lisa/pointeurs/hierarchical-nnlm-aistats05.pdf) Aistats. Vol. 5. 2005.
[7] Michael Gutmann and Aapo Hyvärinen. [“Noise-contrastive estimation: A new estimation principle for unnormalized statistical models.”](http://proceedings.mlr.press/v9/gutmann10a/gutmann10a.pdf) Proc. Intl. Conf. on Artificial Intelligence and Statistics. 2010.
[8] Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg Corrado, and Jeffrey Dean. [“Distributed representations of words and phrases and their compositionality.”](https://papers.nips.cc/paper/5021-distributed-representations-of-words-and-phrases-and-their-compositionality.pdf) Advances in neural information processing systems. 2013.
[9] Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey Dean. [“Efficient estimation of word representations in vector space.”](https://arxiv.org/pdf/1301.3781.pdf) arXiv preprint arXiv:1301.3781 (2013).
[10] Marco Baroni, Georgiana Dinu, and Germán Kruszewski. [“Don’t count, predict! A systematic comparison of context-counting vs. context-predicting semantic vectors.”](http://anthology.aclweb.org/P/P14/P14-1023.pdf) ACL (1). 2014.
[11] Jeffrey Pennington, Richard Socher, and Christopher Manning. [“Glove: Global vectors for word representation.”](http://www.aclweb.org/anthology/D14-1162) Proc. Conf. on empirical methods in natural language processing (EMNLP). 2014.
[Nlp](https://lilianweng.github.io/tags/nlp/) [Language-Model](https://lilianweng.github.io/tags/language-model/) [« Object Detection for Dummies Part 1: Gradient Vector, HOG, and SS](https://lilianweng.github.io/posts/2017-10-29-object-recognition-part-1/) [» Anatomize Deep Learning with Information Theory](https://lilianweng.github.io/posts/2017-09-28-information-bottleneck/) © 2025 [Lil'Log](https://lilianweng.github.io/) Powered by [Hugo](https://gohugo.io/) & [PaperMod](https://git.io/hugopapermod)